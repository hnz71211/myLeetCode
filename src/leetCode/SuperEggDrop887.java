package leetCode;

/**
 * @ClassName: SuperEggDrop
 * @Description: 高楼扔鸡蛋问题
 *
 * 题目是这样：你面前有一栋从 1 到 N 共 N 层的楼，然后给你 K 个鸡蛋（K 至少为 1）。
 * 现在确定这栋楼存在楼层 0 <= F <= N，在这层楼将鸡蛋扔下去，鸡蛋恰好没摔碎（高于 F 的楼层都会碎，低于 F 的楼层都不会碎）。
 * 现在问你，最坏情况下，你至少要扔几次鸡蛋，才能确定这个楼层 F 呢？
 *
 * 如果只有一个鸡蛋（K = 1），只能线性扫描：先在 1 楼扔一下，没碎，再去 2 楼扔一下，没碎，再去 3 楼……
 * 如果有无穷个鸡蛋，最好的策略是使用二分查找思路
 *
 * @Author: hexli
 * @Date: 2020/5/25
 **/
public class SuperEggDrop887 {

  public int superEggDrop(int K, int N) {
    // dp[i][j]含义：现在有 i 个鸡蛋，允许扔 j 次, 最坏情况下最多能确切测试一栋 dp[i][j] 层楼
    int[][] dp = new int[K + 1][N + 1];

    // base case:
    // dp[0][..] = 0
    // dp[..][0] = 0

    int m = 0;
    while (dp[K][m] < N) {
      m++;
      for (int k = 1; k <= K; k++)

        // 1、无论你在哪层楼扔鸡蛋，鸡蛋只可能摔碎或者没摔碎，碎了的话就测楼下，没碎的话就测楼上。
        // 2、无论你上楼还是下楼，总的楼层数 = 楼上的楼层数 + 楼下的楼层数 + 1（当前这层楼）。

        // dp[k][m - 1] 就是楼上的楼层数，因为鸡蛋个数 k 不变，也就是鸡蛋没碎，扔鸡蛋次数 m 减一；
        // dp[k - 1][m - 1] 就是楼下的楼层数，因为鸡蛋个数 k 减一，也就是鸡蛋碎了，同时扔鸡蛋次数 m 减一。
        dp[k][m] = dp[k][m - 1] + dp[k - 1][m - 1] + 1;
    }
    return m;
  }

}
